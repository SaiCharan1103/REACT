{"version":3,"file":"index.mjs","sources":["../src/on-css-function.ts","../src/index.ts","../src/has-supports-at-rule-ancestor.ts"],"sourcesContent":["import valueParser from 'postcss-value-parser';\nimport type { FunctionNode, Dimension, Node, DivNode, WordNode } from 'postcss-value-parser';\n\nfunction onCSSFunction(node: FunctionNode) {\n\tconst value = node.value;\n\tconst rawNodes = node.nodes;\n\tconst relevantNodes = rawNodes.slice().filter((x) => {\n\t\treturn x.type !== 'comment' && x.type !== 'space';\n\t});\n\n\tlet nodes: Rgb | Hsl | null = null;\n\tif (value === 'hsl' || value === 'hsla') {\n\t\tnodes = hslFunctionContents(relevantNodes);\n\t} else if (value === 'rgb' || value === 'rgba') {\n\t\tnodes = rgbFunctionContents(relevantNodes);\n\t}\n\n\tif (!nodes) {\n\t\treturn;\n\t}\n\n\tif (relevantNodes.length > 3 && (!nodes.slash || !nodes.alpha)) {\n\t\treturn;\n\t}\n\n\ttransformAlpha(node, nodes.slash, nodes.alpha);\n\n\t/** Extracted Color channels. */\n\tconst [channelNode1, channelNode2] = channelNodes(nodes);\n\n\tnode.nodes.splice(node.nodes.indexOf(channelNode1) + 1, 0, commaNode());\n\tnode.nodes.splice(node.nodes.indexOf(channelNode2) + 1, 0, commaNode());\n}\n\nexport default onCSSFunction;\n\nfunction commaNode(): DivNode {\n\treturn {\n\t\tsourceIndex: 0,\n\t\tsourceEndIndex: 1,\n\t\tvalue: ',',\n\t\ttype: 'div',\n\t\tbefore: '',\n\t\tafter: '',\n\t};\n}\n\nfunction isNumericNode(node: Node): node is WordNode {\n\tif (!node || node.type !== 'word') {\n\t\treturn false;\n\t}\n\n\tif (!canParseAsUnit(node)) {\n\t\treturn false;\n\t}\n\n\tconst unitAndValue = valueParser.unit(node.value);\n\tif (!unitAndValue) {\n\t\treturn false;\n\t}\n\n\treturn !!unitAndValue.number;\n}\n\nfunction isNumericNodeHueLike(node: Node): node is WordNode {\n\tif (!node || node.type !== 'word') {\n\t\treturn false;\n\t}\n\n\tif (!canParseAsUnit(node)) {\n\t\treturn false;\n\t}\n\n\tconst unitAndValue = valueParser.unit(node.value);\n\tif (!unitAndValue) {\n\t\treturn false;\n\t}\n\n\treturn !!unitAndValue.number && (\n\t\tunitAndValue.unit === 'deg' ||\n\t\tunitAndValue.unit === 'grad' ||\n\t\tunitAndValue.unit === 'rad' ||\n\t\tunitAndValue.unit === 'turn' ||\n\t\tunitAndValue.unit === ''\n\t);\n}\n\nfunction isNumericNodePercentageOrNumber(node: Node): node is WordNode {\n\tif (!node || node.type !== 'word') {\n\t\treturn false;\n\t}\n\n\tif (!canParseAsUnit(node)) {\n\t\treturn false;\n\t}\n\n\tconst unitAndValue = valueParser.unit(node.value);\n\tif (!unitAndValue) {\n\t\treturn false;\n\t}\n\n\treturn unitAndValue.unit === '%' || unitAndValue.unit === '';\n}\n\nfunction isCalcNode(node: Node): node is FunctionNode {\n\treturn node && node.type === 'function' && node.value === 'calc';\n}\n\nfunction isVarNode(node: Node): node is FunctionNode {\n\treturn node && node.type === 'function' && node.value === 'var';\n}\n\nfunction isSlashNode(node: Node): node is DivNode {\n\treturn node && node.type === 'div' && node.value === '/';\n}\n\ntype Hsl = {\n\th: Dimension,\n\thNode: Node,\n\ts: Dimension,\n\tsNode: Node,\n\tl: Dimension,\n\tlNode: Node,\n\tslash?: DivNode,\n\talpha?: WordNode|FunctionNode,\n}\n\nfunction hslFunctionContents(nodes): Hsl|null {\n\tif (!isNumericNodeHueLike(nodes[0])) {\n\t\treturn null;\n\t}\n\n\tif (!isNumericNodePercentageOrNumber(nodes[1])) {\n\t\treturn null;\n\t}\n\n\tif (!isNumericNodePercentageOrNumber(nodes[2])) {\n\t\treturn null;\n\t}\n\n\tconst out: Hsl = {\n\t\th: valueParser.unit(nodes[0].value) as Dimension,\n\t\thNode: nodes[0],\n\t\ts: valueParser.unit(nodes[1].value) as Dimension,\n\t\tsNode: nodes[1],\n\t\tl: valueParser.unit(nodes[2].value) as Dimension,\n\t\tlNode: nodes[2],\n\t};\n\n\tnormalizeHueNode(out.h);\n\tif (out.h.unit !== '') {\n\t\treturn null;\n\t}\n\n\tout.hNode.value = out.h.number;\n\n\tif (isSlashNode(nodes[3])) {\n\t\tout.slash = nodes[3];\n\t}\n\n\tif ((isNumericNodePercentageOrNumber(nodes[4]) || isCalcNode(nodes[4]) || isVarNode(nodes[4]))) {\n\t\tout.alpha = nodes[4];\n\t}\n\n\treturn out;\n}\n\ntype Rgb = {\n\tr: Dimension,\n\trNode: Node,\n\tg: Dimension,\n\tgNode: Node,\n\tb: Dimension,\n\tbNode: Node,\n\tslash?: DivNode,\n\talpha?: WordNode | FunctionNode,\n}\n\nfunction rgbFunctionContents(nodes): Rgb|null {\n\tif (!isNumericNodePercentageOrNumber(nodes[0])) {\n\t\treturn null;\n\t}\n\n\tif (!isNumericNodePercentageOrNumber(nodes[1])) {\n\t\treturn null;\n\t}\n\n\tif (!isNumericNodePercentageOrNumber(nodes[2])) {\n\t\treturn null;\n\t}\n\n\tconst out: Rgb = {\n\t\tr: valueParser.unit(nodes[0].value) as Dimension,\n\t\trNode: nodes[0],\n\t\tg: valueParser.unit(nodes[1].value) as Dimension,\n\t\tgNode: nodes[1],\n\t\tb: valueParser.unit(nodes[2].value) as Dimension,\n\t\tbNode: nodes[2],\n\t};\n\n\tif (out.r.unit === '%') {\n\t\tout.r.number = String(Math.floor(Number(out.r.number) / 100 * 255));\n\t\tout.rNode.value = out.r.number;\n\t}\n\n\tif (out.g.unit === '%') {\n\t\tout.g.number = String(Math.floor(Number(out.g.number) / 100 * 255));\n\t\tout.gNode.value = out.g.number;\n\t}\n\n\tif (out.b.unit === '%') {\n\t\tout.b.number = String(Math.floor(Number(out.b.number) / 100 * 255));\n\t\tout.bNode.value = out.b.number;\n\t}\n\n\tif (isSlashNode(nodes[3])) {\n\t\tout.slash = nodes[3];\n\t}\n\n\tif ((isNumericNodePercentageOrNumber(nodes[4]) || isCalcNode(nodes[4]) || isVarNode(nodes[4]))) {\n\t\tout.alpha = nodes[4];\n\t}\n\n\treturn out;\n}\n\nfunction isRgb(x: Hsl | Rgb): x is Rgb {\n\tif (typeof (x as Rgb).r !== 'undefined') {\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nfunction channelNodes(x: Hsl | Rgb): [Node, Node, Node] {\n\tif (isRgb(x)) {\n\t\treturn [x.rNode, x.gNode, x.bNode];\n\t}\n\n\treturn [x.hNode, x.sNode, x.lNode];\n}\n\nfunction transformAlpha(node: FunctionNode, slashNode: DivNode | undefined, alphaNode: WordNode | FunctionNode | undefined) {\n\tif (node.value === 'hsl' || node.value === 'hsla') {\n\t\tnode.value = 'hsl';\n\t} else if (node.value === 'rgb' || node.value === 'rgba') {\n\t\tnode.value = 'rgb';\n\t}\n\n\tif (!slashNode || !alphaNode) {\n\t\treturn;\n\t}\n\n\tif (node.value === 'hsl') {\n\t\tnode.value = 'hsla';\n\t} else {\n\t\tnode.value = 'rgba';\n\t}\n\n\tslashNode.value = ',';\n\tslashNode.before = '';\n\n\tif (!isNumericNode(alphaNode)) {\n\t\treturn;\n\t}\n\n\tconst unitAndValue = valueParser.unit(alphaNode.value);\n\tif (!unitAndValue) {\n\t\treturn;\n\t}\n\n\tif (unitAndValue.unit === '%') {\n\t\t// transform the Alpha channel from a Percentage to (0-1) Number\n\t\tunitAndValue.number = String(parseFloat(unitAndValue.number) / 100);\n\t\talphaNode.value = String(unitAndValue.number);\n\t}\n}\n\nfunction normaliz